<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>FlashCards Desktop</title>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
        'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;
      margin: 0;
      padding: 20px;
      background-color: #121212;
      color: white;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      min-height: 100vh;
    }
    
    h1 {
      margin-bottom: 10px;
      color: #90caf9;
    }
    
    p {
      margin-bottom: 20px;
      text-align: center;
      max-width: 600px;
    }

    .container {
      display: flex;
      flex-direction: column;
      align-items: center;
      width: 100%;
      max-width: 800px;
    }

    .info-container {
      background-color: #1e1e1e;
      border-radius: 8px;
      padding: 20px;
      margin-top: 20px;
      width: 100%;
    }

    .info-item {
      display: flex;
      justify-content: space-between;
      margin-bottom: 10px;
      border-bottom: 1px solid #333;
      padding-bottom: 10px;
    }

    .info-label {
      font-weight: bold;
      color: #90caf9;
    }

    .info-value {
      color: #bbb;
    }

    button {
      background-color: #90caf9;
      color: #121212;
      border: none;
      border-radius: 4px;
      padding: 8px 16px;
      font-size: 14px;
      cursor: pointer;
      margin-top: 10px;
      transition: background-color 0.3s;
    }

    button:hover {
      background-color: #64b5f6;
    }

    button:disabled {
      background-color: #555;
      cursor: not-allowed;
    }

    .button-container {
      display: flex;
      gap: 10px;
      margin-top: 20px;
      flex-wrap: wrap;
      justify-content: center;
    }

    .screen {
      display: none;
      width: 100%;
    }

    .screen.active {
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .card {
      background-color: #1e1e1e;
      border-radius: 8px;
      padding: 30px;
      margin-top: 20px;
      width: 100%;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
      text-align: center;
    }

    .card-content {
      font-size: 24px;
      margin-bottom: 20px;
    }

    .progress-bar {
      width: 100%;
      height: 8px;
      background-color: #333;
      border-radius: 4px;
      margin: 20px 0;
      overflow: hidden;
    }

    .progress-value {
      height: 100%;
      background-color: #90caf9;
      border-radius: 4px;
      transition: width 0.3s ease;
    }

    .feedback {
      margin-top: 20px;
      padding: 15px;
      border-radius: 8px;
      text-align: center;
    }

    .feedback.correct {
      background-color: rgba(76, 175, 80, 0.2);
      color: #81c784;
    }
    
    .feedback.incorrect {
      background-color: rgba(244, 67, 54, 0.2);
      color: #e57373;
    }

    .session-stats {
      display: flex;
      flex-wrap: wrap;
      justify-content: space-between;
      margin-top: 20px;
    }

    .stats-item {
      flex: 1;
      min-width: 120px;
      text-align: center;
      margin: 10px;
    }

    .stats-value {
      font-size: 32px;
      font-weight: bold;
      color: #90caf9;
    }

    .stats-label {
      font-size: 14px;
      color: #bbb;
    }

    .form-group {
      margin-bottom: 20px;
      width: 100%;
    }

    .form-group label {
      display: block;
      margin-bottom: 8px;
      font-weight: bold;
      color: #90caf9;
    }

    .form-group select, .form-group input {
      width: 100%;
      padding: 10px;
      border-radius: 4px;
      border: 1px solid #333;
      background-color: #2c2c2c;
      color: white;
      font-size: 16px;
    }

    textarea {
      width: 100%;
      padding: 10px;
      border-radius: 4px;
      border: 1px solid #333;
      background-color: #2c2c2c;
      color: white;
      font-size: 16px;
      resize: vertical;
      min-height: 100px;
      margin-bottom: 20px;
    }

    /* Notification System Styles */
    .notification-container {
      position: fixed;
      top: 20px;
      right: 20px;
      max-width: 400px;
      z-index: 9999;
      transition: all 0.3s ease;
    }

    .notification {
      margin-bottom: 10px;
      padding: 15px;
      border-radius: 4px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
      display: flex;
      flex-direction: column;
      opacity: 0;
      transform: translateY(-20px);
      transition: opacity 0.3s, transform 0.3s;
    }

    .notification.show {
      opacity: 1;
      transform: translateY(0);
    }

    .notification-title {
      font-weight: bold;
      margin-bottom: 5px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .notification-close {
      cursor: pointer;
      font-size: 16px;
      opacity: 0.7;
    }

    .notification-close:hover {
      opacity: 1;
    }

    .notification-content {
      margin-bottom: 10px;
    }

    .notification-details {
      font-size: 12px;
      margin-top: 5px;
      color: rgba(255, 255, 255, 0.7);
      border-top: 1px solid rgba(255, 255, 255, 0.1);
      padding-top: 5px;
    }

    .notification-actions {
      display: flex;
      justify-content: flex-end;
      gap: 8px;
      margin-top: 8px;
    }

    .notification-btn {
      padding: 5px 10px;
      border-radius: 4px;
      border: none;
      font-size: 12px;
      cursor: pointer;
      background-color: rgba(255, 255, 255, 0.2);
      color: white;
    }

    .notification-btn:hover {
      background-color: rgba(255, 255, 255, 0.3);
    }

    /* Notification types */
    .notification.error {
      background-color: rgba(244, 67, 54, 0.9);
      color: white;
    }

    .notification.warning {
      background-color: rgba(255, 152, 0, 0.9);
      color: white;
    }

    .notification.info {
      background-color: rgba(33, 150, 243, 0.9);
      color: white;
    }

    .notification.success {
      background-color: rgba(76, 175, 80, 0.9);
      color: white;
    }

    /* Tag selection styles */
    .tag-selection-container {
      margin-top: 20px;
      width: 100%;
    }

    .tag-selection-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 10px 15px;
      background-color: #2c2c2c;
      border-radius: 4px;
      cursor: pointer;
      margin-bottom: 0;
      color: white;
      border: 2px solid transparent;
      transition: all 0.2s ease;
      text-align: left;
      width: 100%;
    }

    .tag-selection-header:hover {
      background-color: #333;
    }

    .tag-selection-header:focus {
      outline: none;
      border-color: #90caf9;
      box-shadow: 0 0 0 2px rgba(144, 202, 249, 0.5);
    }

    .tag-selection-summary {
      font-size: 0.9em;
      color: #bbb;
      margin-left: 10px;
    }

    .tag-selection-content {
      padding: 15px;
      background-color: #1e1e1e;
      border-radius: 0 0 4px 4px;
      display: none;
      max-height: 250px;
      overflow-y: auto;
      border: 1px solid #333;
      border-top: none;
    }

    .tag-selection-content.open {
      display: block;
    }

    .tag-cloud {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-bottom: 15px;
    }

    .tag-toggle {
      background-color: #2c2c2c;
      border: 1px solid #444;
      color: white;
      padding: 6px 12px;
      padding-left: 24px;  /* Space for the selection indicator */
      border-radius: 15px;
      cursor: pointer;
      font-size: 14px;
      transition: all 0.2s ease;
      position: relative;
      display: inline-flex;
      align-items: center;
    }

    .tag-toggle::before {
      content: '';
      position: absolute;
      left: 8px;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      border: 1px solid #666;
      transition: all 0.2s ease;
    }

    .tag-toggle:hover {
      background-color: #333;
    }

    .tag-toggle:focus {
      outline: none;
      box-shadow: 0 0 0 2px rgba(144, 202, 249, 0.5);
    }

    .tag-toggle.selected {
      background-color: #1e3a5a;
      border-color: #90caf9;
      color: #90caf9;
    }

    .tag-toggle.selected::before {
      background-color: #90caf9;
      border-color: #90caf9;
    }

    .tag-count {
      color: #90caf9;
      margin-left: 5px;
      font-size: 0.8em;
      opacity: 0.8;
    }

    .tag-selection-actions {
      display: flex;
      justify-content: flex-end;
      margin-top: 15px;
      gap: 12px;
      border-top: 1px solid #333;
      padding-top: 15px;
    }

    .tag-action-btn {
      background-color: #2c2c2c;
      border: 1px solid #444;
      color: white;
      padding: 6px 12px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      transition: all 0.2s ease;
    }

    .tag-action-btn:hover {
      background-color: #333;
    }

    .tag-action-btn:focus {
      outline: none;
      box-shadow: 0 0 0 2px rgba(144, 202, 249, 0.5);
    }

    /* Screen reader only text */
    .sr-only {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border-width: 0;
    }
  </style>
</head>
<body>
  <!-- Notification Container -->
  <div id="notification-container" class="notification-container"></div>

  <div class="container">
    <h1>FlashCards Desktop</h1>
    <p>A language learning application to create and practice flashcards</p>

    <!-- Home Screen -->
    <div id="home-screen" class="screen active">
      <div class="info-container">
        <h2>Database Information</h2>
        <div id="db-stats">
          <div class="info-item">
            <span class="info-label">FlashCards:</span>
            <span class="info-value" id="flashcards-count">Loading...</span>
          </div>
          <div class="info-item">
            <span class="info-label">Practice Sessions:</span>
            <span class="info-value" id="sessions-count">Loading...</span>
          </div>
          <div class="info-item">
            <span class="info-label">Active Sessions:</span>
            <span class="info-value" id="active-sessions-count">Loading...</span>
          </div>
          <div class="info-item">
            <span class="info-label">Completed Sessions:</span>
            <span class="info-value" id="completed-sessions-count">Loading...</span>
          </div>
        </div>
      </div>

      <div class="info-container">
        <h2>App Information</h2>
        <div id="version-info">
          <div class="info-item">
            <span class="info-label">Node.js Version:</span>
            <span class="info-value" id="node-version">Loading...</span>
          </div>
          <div class="info-item">
            <span class="info-label">Chromium Version:</span>
            <span class="info-value" id="chrome-version">Loading...</span>
          </div>
          <div class="info-item">
            <span class="info-label">Electron Version:</span>
            <span class="info-value" id="electron-version">Loading...</span>
          </div>
        </div>
      </div>


      <div class="button-container">
        <button id="start-practice-btn" class="primary-button" style="font-size: 16px; padding: 12px 24px;">Start Practice Session</button>
        <button id="refresh-stats">Refresh Stats</button>
        <button id="create-sample-card">Create Sample Card</button>
      </div>

      <!-- Database Management -->
      <div class="info-container" style="margin-top: 40px;">
        <h2>Database Management</h2>
        <p>Import or export your flashcards, sessions, and settings.</p>
        <div class="button-container">
          <button id="export-data-btn">Export Data</button>
          <button id="import-data-btn">Import Data</button>
        </div>
      </div>
    </div>

    <!-- Session Setup Screen -->
    <div id="setup-screen" class="screen">
      <div class="info-container">
        <h2>Practice Session Setup</h2>
        <div class="form-group">
          <label for="source-language">Source Language:</label>
          <select id="source-language">
            <option value="de">German</option>
            <option value="en">English</option>
            <option value="fr">French</option>
            <option value="es">Spanish</option>
          </select>
        </div>
        <div class="form-group">
          <label for="target-language">Target Language:</label>
          <select id="target-language">
            <option value="en">English</option>
            <option value="de">German</option>
            <option value="fr">French</option>
            <option value="es">Spanish</option>
          </select>
        </div>
        <div class="form-group">
          <label for="card-count">Number of Cards:</label>
          <input type="number" id="card-count" min="5" max="20" value="10">
        </div>

        <!-- Tag Selection Component -->
        <div id="tag-selection-container" class="tag-selection-container" style="display: none;">
          <button
            class="tag-selection-header"
            id="tag-selection-header"
            aria-expanded="false"
            aria-controls="tag-selection-content"
            aria-haspopup="true">
            <span>Select Tags</span>
            <span id="tag-selection-summary" class="tag-selection-summary" aria-live="polite">All tags selected</span>
            <span id="tag-selection-toggle" aria-hidden="true">▼</span>
          </button>
          <div
            class="tag-selection-content"
            id="tag-selection-content"
            role="region"
            aria-labelledby="tag-selection-header">

            <!-- Selection status announced to screen readers but visually hidden -->
            <div class="sr-only" aria-live="polite" id="tag-selection-status"></div>

            <!-- Tag Cloud will be dynamically added here -->
            <div id="tag-cloud" class="tag-cloud" role="group" aria-label="Available tags">
              <div class="tag-loading">Loading tags...</div>
            </div>

            <!-- Untagged option as a button -->
            <button
              type="button"
              id="include-untagged"
              class="tag-toggle selected"
              aria-pressed="true"
              aria-describedby="untagged-desc">
              <span>Untagged cards</span>
              <span class="tag-count" id="untagged-count">(0)</span>
              <span id="untagged-desc" class="sr-only">Toggle selection of cards without tags</span>
            </button>

            <!-- Actions -->
            <div class="tag-selection-actions">
              <button
                type="button"
                class="tag-action-btn"
                id="select-all-tags"
                aria-controls="tag-cloud include-untagged">
                Select All
              </button>
              <button
                type="button"
                class="tag-action-btn"
                id="deselect-all-tags"
                aria-controls="tag-cloud include-untagged">
                Deselect All
              </button>
            </div>
          </div>
        </div>
      </div>
      <div class="button-container">
        <button id="back-to-home-btn">Back</button>
        <button id="create-session-btn">Start Session</button>
      </div>
    </div>

    <!-- Practice Screen -->
    <div id="practice-screen" class="screen">
      <div class="progress-bar">
        <div class="progress-value" id="session-progress"></div>
      </div>
      <div class="card">
        <div class="card-content" id="card-content"></div>
      </div>
      <div class="form-group">
        <label for="translation-input">Your Translation:</label>
        <textarea id="translation-input" placeholder="Type your translation here..."></textarea>
      </div>
      <div class="button-container">
        <button id="submit-answer-btn">Submit Answer</button>
      </div>
    </div>

    <!-- Feedback Screen -->
    <div id="feedback-screen" class="screen">
      <div class="progress-bar">
        <div class="progress-value" id="feedback-progress"></div>
      </div>
      <div class="card">
        <div class="card-content" id="feedback-original"></div>
      </div>
      <div id="feedback-result" class="feedback"></div>
      <div class="info-container">
        <div class="info-item">
          <span class="info-label">Your Translation:</span>
          <span class="info-value" id="feedback-user-answer"></span>
        </div>
        <div class="info-item">
          <span class="info-label">Suggested Translation:</span>
          <span class="info-value" id="feedback-suggested"></span>
        </div>
      </div>
      <div class="button-container">
        <button id="next-card-btn">Next Card</button>
      </div>
    </div>

    <!-- Results Screen -->
    <div id="results-screen" class="screen">
      <div class="info-container">
        <h2>Session Results</h2>
        <div class="session-stats">
          <div class="stats-item">
            <div class="stats-value" id="results-total">0</div>
            <div class="stats-label">Total Cards</div>
          </div>
          <div class="stats-item">
            <div class="stats-value" id="results-correct">0</div>
            <div class="stats-label">Correct</div>
          </div>
          <div class="stats-item">
            <div class="stats-value" id="results-accuracy">0%</div>
            <div class="stats-label">Accuracy</div>
          </div>
        </div>
      </div>
      <div class="button-container">
        <button id="back-to-home-from-results-btn">Back to Home</button>
        <button id="start-new-session-btn">Start New Session</button>
      </div>
    </div>

    <!-- Import Screen -->
    <div id="import-screen" class="screen">
      <div class="info-container">
        <h2>Import Data</h2>
        <p>Select how you want to import your data:</p>
        <div class="form-group">
          <label for="import-mode">Import Mode:</label>
          <select id="import-mode">
            <option value="merge">Merge - Add to existing data</option>
            <option value="replace">Replace - Clear existing data first</option>
          </select>
        </div>
      </div>
      <div class="button-container">
        <button id="back-from-import-btn">Cancel</button>
        <button id="proceed-import-btn">Import File</button>
      </div>
    </div>

    <!-- Import/Export Result Screen -->
    <div id="operation-result-screen" class="screen">
      <div class="info-container">
        <h2 id="operation-result-title">Operation Result</h2>
        <div id="operation-result-content" class="feedback"></div>
        <div id="operation-result-stats" class="session-stats">
          <!-- Stats will be dynamically inserted here -->
        </div>
        <div id="operation-result-path-container" style="display: none; margin-top: 20px; border-top: 1px solid #333; padding-top: 10px;">
          <div class="info-item">
            <span class="info-label">File Location:</span>
            <span class="info-value" id="operation-result-path" style="word-break: break-all;"></span>
          </div>
        </div>
      </div>
      <div class="button-container">
        <button id="back-to-home-from-result-btn">Back to Home</button>
      </div>
    </div>
  </div>

  <script>
    // State management
    const state = {
      sessionId: null,
      currentCard: null,
      lastAnswer: null,
      lastEvaluation: null
    };

    // Screen management
    const screens = {
      home: document.getElementById('home-screen'),
      setup: document.getElementById('setup-screen'),
      practice: document.getElementById('practice-screen'),
      feedback: document.getElementById('feedback-screen'),
      results: document.getElementById('results-screen'),
      import: document.getElementById('import-screen'),
      operationResult: document.getElementById('operation-result-screen')
    };

    function showScreen(screenName) {
      // Hide all screens
      Object.values(screens).forEach(screen => {
        screen.classList.remove('active');
      });
      
      // Show the requested screen
      screens[screenName].classList.add('active');
    }

    // Display version information
    document.getElementById('node-version').textContent = window.versions.node();
    document.getElementById('chrome-version').textContent = window.versions.chrome();
    document.getElementById('electron-version').textContent = window.versions.electron();

    // Load database stats
    async function loadDatabaseStats() {
      try {
        const stats = await window.flashcards.getDatabaseStats();
        document.getElementById('flashcards-count').textContent = stats.flashcardsCount;
        document.getElementById('sessions-count').textContent = stats.sessionsCount;
        document.getElementById('active-sessions-count').textContent = stats.activeSessionsCount;
        document.getElementById('completed-sessions-count').textContent = stats.completedSessionsCount;
      } catch (error) {
        console.error('Error loading database stats:', error);
      }
    }

    // Create a sample flashcard
    async function createSampleCard() {
      try {
        const sampleCard = {
          content: 'Hello',
          sourceLanguage: 'en',
          comment: 'A basic greeting',
          userTranslation: '',
          tags: ['greeting', 'basic']
        };

        const savedCard = await window.flashcards.saveFlashCard(sampleCard);
        console.log('Sample card created:', savedCard);

        // Refresh stats after creating a card
        await loadDatabaseStats();

        // Show success notification
        notificationSystem.success('Card Created', 'Sample card created successfully!');
      } catch (error) {
        console.error('Error creating sample card:', error);

        // Show error notification
        notificationSystem.error(
          'Card Creation Failed',
          'Failed to create sample card',
          error.message
        );
      }
    }

    // Load tags for selection
    async function loadTagsForSelection(sourceLanguage) {
      try {
        const tagSelectionContainer = document.getElementById('tag-selection-container');
        const tagCloudContainer = document.getElementById('tag-cloud');
        const untaggedCountElement = document.getElementById('untagged-count');
        const tagSummaryElement = document.getElementById('tag-selection-summary');
        const tagStatusElement = document.getElementById('tag-selection-status');

        // Show loading
        tagCloudContainer.innerHTML = '<div class="tag-loading">Loading tags...</div>';

        // Fetch tags for the selected source language
        const tagsData = await window.flashcards.getAvailableTags(sourceLanguage);
        console.log('Available tags:', tagsData);

        // Check if we have any tags
        if (tagsData.tags.length === 0 && tagsData.untaggedCount === 0) {
          // No tags and no cards, hide the entire container
          tagSelectionContainer.style.display = 'none';
          return;
        }

        // Show the container
        tagSelectionContainer.style.display = 'block';

        // Update untagged count
        untaggedCountElement.textContent = `(${tagsData.untaggedCount})`;

        // Create tag buttons for each tag
        let tagsHTML = '';
        if (tagsData.tags.length === 0) {
          tagsHTML = '<div class="no-tags-message" role="status">No tags available</div>';
        } else {
          tagsData.tags.forEach((tagData, index) => {
            tagsHTML += `
              <button
                type="button"
                id="tag-${tagData.tag}"
                class="tag-toggle selected"
                data-tag="${tagData.tag}"
                aria-pressed="true"
                aria-describedby="tag-desc-${tagData.tag}"
                tabindex="0">
                <span>${tagData.tag}</span>
                <span class="tag-count">(${tagData.count})</span>
                <span id="tag-desc-${tagData.tag}" class="sr-only">Toggle selection of tag ${tagData.tag} with ${tagData.count} cards</span>
              </button>
            `;
          });
        }

        // Update the container
        tagCloudContainer.innerHTML = tagsHTML;

        // Update summary text
        const totalTagCount = tagsData.tags.length + (tagsData.untaggedCount > 0 ? 1 : 0);
        tagSummaryElement.textContent = `All ${totalTagCount} tags selected`;

        // Update screen reader status
        tagStatusElement.textContent = `Loaded ${tagsData.tags.length} tags. All ${totalTagCount} tags are currently selected.`;

        // Show tag selection only if there's more than one tag or if there are both tagged and untagged cards
        const hasMultipleTagOptions = tagsData.tags.length > 1 || (tagsData.tags.length === 1 && tagsData.untaggedCount > 0);

        if (!hasMultipleTagOptions) {
          // Just one tag option (or only untagged cards), hide the container
          tagSelectionContainer.style.display = 'none';
        }

        // Add event listeners to the tag buttons
        document.querySelectorAll('.tag-toggle').forEach(button => {
          // Click event
          button.addEventListener('click', () => {
            toggleTagSelection(button);
          });

          // Keyboard event handling
          button.addEventListener('keydown', (event) => {
            // Toggle on Enter or Space
            if (event.key === 'Enter' || event.key === ' ') {
              event.preventDefault();
              toggleTagSelection(button);
            }

            // Arrow key navigation between tags
            else if (event.key === 'ArrowRight' || event.key === 'ArrowDown') {
              event.preventDefault();
              const nextButton = findNextFocusableElement(button, true);
              if (nextButton) nextButton.focus();
            }
            else if (event.key === 'ArrowLeft' || event.key === 'ArrowUp') {
              event.preventDefault();
              const prevButton = findNextFocusableElement(button, false);
              if (prevButton) prevButton.focus();
            }
            else if (event.key === 'Home') {
              event.preventDefault();
              const firstButton = document.querySelector('.tag-toggle');
              if (firstButton) firstButton.focus();
            }
            else if (event.key === 'End') {
              event.preventDefault();
              const allButtons = document.querySelectorAll('.tag-toggle');
              const lastButton = allButtons[allButtons.length - 1];
              if (lastButton) lastButton.focus();
            }
            else if (event.key === 'Escape') {
              event.preventDefault();
              // Close the tag selection panel and move focus back to header
              const header = document.getElementById('tag-selection-header');
              toggleTagSelectionAccordion();
              if (header) header.focus();
            }
          });
        });

        // Helper function to find the next focusable element
        function findNextFocusableElement(currentElement, forward = true) {
          const focusableElements = Array.from(
            document.querySelectorAll('.tag-toggle, .tag-action-btn')
          );

          const currentIndex = focusableElements.indexOf(currentElement);

          if (currentIndex === -1) return null;

          let nextIndex;
          if (forward) {
            nextIndex = (currentIndex + 1) % focusableElements.length;
          } else {
            nextIndex = (currentIndex - 1 + focusableElements.length) % focusableElements.length;
          }

          return focusableElements[nextIndex];
        }
      } catch (error) {
        console.error('Error loading tags:', error);
        const tagCloudContainer = document.getElementById('tag-cloud');
        tagCloudContainer.innerHTML = '<div class="error-message" role="alert">Failed to load tags. Please try again.</div>';

        notificationSystem.error(
          'Tag Loading Failed',
          'Failed to load available tags',
          error.message
        );
      }
    }

    // Toggle tag selection and update status
    function toggleTagSelection(button) {
      const isSelected = button.classList.contains('selected');
      const newState = !isSelected;
      const tagName = button.dataset.tag || (button.id === 'include-untagged' ? 'untagged cards' : button.textContent.trim());

      // Update button state
      button.classList.toggle('selected', newState);
      button.setAttribute('aria-pressed', newState.toString());

      // Announce to screen readers
      const statusMessage = newState ?
        `Selected ${tagName}` :
        `Deselected ${tagName}`;
      document.getElementById('tag-selection-status').textContent = statusMessage;

      // Update summary text in the dropdown header
      updateTagSelectionSummary();
    }

    // Update the tag selection summary text
    function updateTagSelectionSummary() {
      const totalTagButtons = document.querySelectorAll('.tag-toggle').length;
      const selectedTagButtons = document.querySelectorAll('.tag-toggle.selected').length;
      const tagSummaryElement = document.getElementById('tag-selection-summary');
      const tagStatusElement = document.getElementById('tag-selection-status');

      let summaryText = '';
      if (selectedTagButtons === 0) {
        summaryText = 'No tags selected';
      } else if (selectedTagButtons === totalTagButtons) {
        summaryText = `All ${totalTagButtons} tags selected`;
      } else {
        summaryText = `${selectedTagButtons} of ${totalTagButtons} tags selected`;
      }

      tagSummaryElement.textContent = summaryText;

      // Update screen reader status with more detailed information
      const selectedTags = Array.from(document.querySelectorAll('.tag-toggle.selected'))
        .map(button => button.dataset.tag || (button.id === 'include-untagged' ? 'untagged cards' : ''))
        .filter(tag => tag);

      let statusMessage = summaryText;
      if (selectedTags.length > 0 && selectedTags.length <= 5) {
        statusMessage += `. Selected tags: ${selectedTags.join(', ')}`;
      }

      // Only update the tag status if it's different to avoid repeated announcements
      if (tagStatusElement.textContent !== statusMessage) {
        tagStatusElement.textContent = statusMessage;
      }
    }

    // Create and start a practice session
    async function createSession() {
      try {
        const sourceLanguage = document.getElementById('source-language').value;
        const targetLanguage = document.getElementById('target-language').value;
        const maxCards = parseInt(document.getElementById('card-count').value, 10);

        if (sourceLanguage === targetLanguage) {
          notificationSystem.warning(
            'Invalid Languages',
            'Source and target languages must be different!',
            [{
              label: 'Change Languages',
              action: () => {
                // Focus on the target language dropdown
                document.getElementById('target-language').focus();
              }
            }]
          );
          return;
        }

        // Use real cards from the database if there are enough,
        // otherwise fall back to sample cards
        const stats = await window.flashcards.getDatabaseStats();
        const useSampleCards = stats.flashcardsCount < 5; // Fallback to samples if not enough cards
        console.log(`Creating session with: sourceLanguage=${sourceLanguage}, targetLanguage=${targetLanguage}, useSampleCards=${useSampleCards}`);

        // If using sample cards, inform the user
        if (useSampleCards && stats.flashcardsCount === 0) {
          notificationSystem.info(
            'Using Sample Cards',
            'No flashcards found in database. Using sample cards for this session.'
          );
        }

        // Get selected tags if the container is visible
        const tagSelectionContainer = document.getElementById('tag-selection-container');
        let selectedTags = [];
        let includeUntagged = false;

        if (tagSelectionContainer.style.display !== 'none') {
          // Get all selected tag buttons
          const tagButtons = document.querySelectorAll('.tag-toggle.selected');
          selectedTags = Array.from(tagButtons)
            .filter(button => button.id !== 'include-untagged')
            .map(button => button.dataset.tag);

          // Check if untagged cards should be included
          includeUntagged = document.getElementById('include-untagged').classList.contains('selected');
        }

        console.log('Selected tags:', selectedTags);
        console.log('Include untagged:', includeUntagged);

        const sessionData = await window.flashcards.createGameSession({
          sourceLanguage,
          targetLanguage,
          maxCards,
          useSampleCards: useSampleCards,
          tags: selectedTags,
          includeUntagged: includeUntagged
        });

        console.log('Session created with card IDs:', sessionData.cardIds);

        state.sessionId = sessionData.id;
        console.log('Created session:', sessionData);

        // Load the first card
        await loadCurrentCard();

        // Show practice screen
        showScreen('practice');
      } catch (error) {
        console.error('Error creating session:', error);

        notificationSystem.error(
          'Session Creation Failed',
          'Could not create practice session',
          error.message,
          [{
            label: 'Try Again',
            action: () => {
              // Re-enable the create button if it was disabled
              const createBtn = document.getElementById('create-session-btn');
              createBtn.disabled = false;
            }
          }]
        );
      }
    }

    // Load the current card in the session
    async function loadCurrentCard() {
      try {
        const cardData = await window.flashcards.getCurrentCard(state.sessionId);
        
        if (!cardData) {
          // Session is complete
          showResults();
          return;
        }
        
        state.currentCard = cardData;
        
        // Update UI
        document.getElementById('card-content').textContent = cardData.card.content;
        
        // Update progress
        const progressPercent = (cardData.sessionProgress.current / cardData.sessionProgress.total) * 100;
        document.getElementById('session-progress').style.width = `${progressPercent}%`;
        
        // Clear the input
        document.getElementById('translation-input').value = '';
      } catch (error) {
        console.error('Error loading current card:', error);
        alert('Error loading card: ' + error.message);
      }
    }

    // Submit an answer for evaluation
    async function submitAnswer() {
      try {
        const answer = document.getElementById('translation-input').value.trim();

        if (!answer) {
          notificationSystem.warning(
            'Empty Translation',
            'Please enter a translation before submitting!'
          );
          return;
        }

        // Disable submit button to prevent double submission
        const submitBtn = document.getElementById('submit-answer-btn');
        const originalText = submitBtn.textContent;
        submitBtn.disabled = true;
        submitBtn.textContent = 'Evaluating...';

        const result = await window.flashcards.submitAnswer(state.sessionId, answer);

        // Re-enable submit button
        submitBtn.disabled = false;
        submitBtn.textContent = originalText;

        state.lastAnswer = answer;
        state.lastEvaluation = result;

        // If there was a translation issue but we managed to continue, show an info notification
        if (result._hadTranslationError) {
          notificationSystem.info(
            'Translation Note',
            'Using simplified translation due to service unavailability.'
          );
        }

        showFeedback(result);
      } catch (error) {
        console.error('Error submitting answer:', error);

        // Re-enable submit button
        const submitBtn = document.getElementById('submit-answer-btn');
        submitBtn.disabled = false;
        submitBtn.textContent = 'Submit Answer';

        notificationSystem.error(
          'Submission Error',
          'Failed to submit your answer',
          error.message,
          [{
            label: 'Try Again',
            action: () => {
              // Focus back on the input
              document.getElementById('translation-input').focus();
            }
          }]
        );
      }
    }

    // Show feedback for the submitted answer
    function showFeedback(result) {
      // Update progress in the feedback screen
      const progressPercent = (state.currentCard.sessionProgress.current / state.currentCard.sessionProgress.total) * 100;
      document.getElementById('feedback-progress').style.width = `${progressPercent}%`;
      
      // Show the original text
      document.getElementById('feedback-original').textContent = state.currentCard.card.content;
      
      // Show the user's answer
      document.getElementById('feedback-user-answer').textContent = state.lastAnswer;
      
      // Show the suggested translation
      document.getElementById('feedback-suggested').textContent = result.referenceTranslation;
      
      // Show the feedback message
      const feedbackElement = document.getElementById('feedback-result');
      feedbackElement.textContent = result.evaluation.feedback;
      
      if (result.evaluation.correct) {
        feedbackElement.classList.add('correct');
        feedbackElement.classList.remove('incorrect');
      } else {
        feedbackElement.classList.add('incorrect');
        feedbackElement.classList.remove('correct');
      }
      
      // Show the feedback screen
      showScreen('feedback');
    }

    // Advance to the next card
    async function nextCard() {
      try {
        const result = await window.flashcards.advanceSession(state.sessionId);
        
        if (result.isComplete) {
          // Session is complete, show results
          showResults();
        } else {
          // Load the next card
          await loadCurrentCard();
          showScreen('practice');
        }
      } catch (error) {
        console.error('Error advancing session:', error);
        alert('Error advancing to next card: ' + error.message);
      }
    }

    // Show the results screen
    async function showResults() {
      try {
        const stats = await window.flashcards.getSessionStats(state.sessionId);
        
        // Update results UI
        document.getElementById('results-total').textContent = stats.stats.totalCards;
        document.getElementById('results-correct').textContent = stats.stats.correctCards;
        document.getElementById('results-accuracy').textContent = Math.round(stats.stats.accuracy) + '%';
        
        // Show the results screen
        showScreen('results');
        
        // Refresh database stats
        await loadDatabaseStats();
      } catch (error) {
        console.error('Error showing results:', error);
        alert('Error showing results: ' + error.message);
      }
    }

    // Notification System
    const notificationSystem = {
      container: document.getElementById('notification-container'),
      notifications: [],
      idCounter: 0,

      /**
       * Show a notification
       * @param {Object} options - Notification options
       * @param {string} options.type - Notification type ('error', 'warning', 'info', 'success')
       * @param {string} options.title - Notification title
       * @param {string} options.message - Notification message
       * @param {string} [options.details] - Optional detailed error information
       * @param {number} [options.duration] - Auto-dismiss duration in ms (0 for no auto-dismiss)
       * @param {Array} [options.actions] - Array of action buttons {label, action}
       * @returns {string} Notification ID
       */
      show: function(options) {
        const { type = 'info', title, message, details, duration = 5000, actions = [] } = options;
        const id = 'notification-' + (++this.idCounter);

        // Create notification element
        const notificationEl = document.createElement('div');
        notificationEl.className = 'notification ' + type;
        notificationEl.id = id;

        // Create notification content
        let html = `
          <div class="notification-title">
            <span>${title}</span>
            <span class="notification-close" data-id="${id}">&times;</span>
          </div>
          <div class="notification-content">${message}</div>
        `;

        // Add details if provided
        if (details) {
          html += `<div class="notification-details">${details}</div>`;
        }

        // Add action buttons if provided
        if (actions.length > 0) {
          html += '<div class="notification-actions">';
          actions.forEach((action, index) => {
            html += `<button class="notification-btn" data-id="${id}" data-action="${index}">${action.label}</button>`;
          });
          html += '</div>';
        }

        notificationEl.innerHTML = html;

        // Add to container
        this.container.appendChild(notificationEl);

        // Track the notification
        const notificationObj = {
          id,
          element: notificationEl,
          actions,
          timer: null
        };

        this.notifications.push(notificationObj);

        // Register event listeners
        notificationEl.querySelector('.notification-close').addEventListener('click', () => {
          this.dismiss(id);
        });

        // Register action button listeners
        const actionButtons = notificationEl.querySelectorAll('.notification-btn');
        actionButtons.forEach(button => {
          button.addEventListener('click', (e) => {
            const actionIndex = parseInt(e.target.dataset.action, 10);
            if (actions[actionIndex] && typeof actions[actionIndex].action === 'function') {
              actions[actionIndex].action();
            }
            this.dismiss(id);
          });
        });

        // Show with animation
        setTimeout(() => {
          notificationEl.classList.add('show');
        }, 10);

        // Auto-dismiss if duration is set
        if (duration > 0) {
          notificationObj.timer = setTimeout(() => {
            this.dismiss(id);
          }, duration);
        }

        return id;
      },

      /**
       * Dismiss a notification by ID
       * @param {string} id - Notification ID
       */
      dismiss: function(id) {
        const index = this.notifications.findIndex(n => n.id === id);
        if (index === -1) return;

        const notification = this.notifications[index];

        // Clear timer if exists
        if (notification.timer) {
          clearTimeout(notification.timer);
        }

        // Remove animation
        notification.element.classList.remove('show');

        // Wait for animation to complete, then remove from DOM
        setTimeout(() => {
          if (notification.element.parentNode) {
            notification.element.parentNode.removeChild(notification.element);
          }
          this.notifications.splice(index, 1);
        }, 300);
      },

      /**
       * Show an error notification
       * @param {string} title - Error title
       * @param {string} message - Error message
       * @param {string} [details] - Detailed error information
       * @param {Array} [actions] - Array of action buttons
       */
      error: function(title, message, details, actions) {
        return this.show({
          type: 'error',
          title,
          message,
          details,
          duration: 0, // Errors don't auto-dismiss
          actions: actions || [
            {
              label: 'Copy Error',
              action: () => {
                const textToCopy = `${title}: ${message}\n${details || ''}`;
                navigator.clipboard.writeText(textToCopy).catch(err => {
                  console.error('Could not copy error:', err);
                });
              }
            }
          ]
        });
      },

      /**
       * Show a warning notification
       * @param {string} title - Warning title
       * @param {string} message - Warning message
       * @param {Array} [actions] - Array of action buttons
       */
      warning: function(title, message, actions) {
        return this.show({
          type: 'warning',
          title,
          message,
          duration: 7000,
          actions
        });
      },

      /**
       * Show an info notification
       * @param {string} title - Info title
       * @param {string} message - Info message
       * @param {Array} [actions] - Array of action buttons
       */
      info: function(title, message, actions) {
        return this.show({
          type: 'info',
          title,
          message,
          duration: 5000,
          actions
        });
      },

      /**
       * Show a success notification
       * @param {string} title - Success title
       * @param {string} message - Success message
       */
      success: function(title, message) {
        return this.show({
          type: 'success',
          title,
          message,
          duration: 3000
        });
      }
    };

    // Handle errors from IPC
    window.addEventListener('flashcards:error', (event) => {
      const { type, title, message, details, source } = event.detail;

      console.error(`[${source}] ${title}: ${message}`, details);

      let actions = [];

      // For translation API errors, add setup action
      if (source === 'translation') {
        actions.push({
          label: 'Setup API Key',
          action: () => {
            // This would show a settings dialog - placeholder for now
            alert('API key setup is not implemented yet.');
          }
        });
      }

      notificationSystem.error(title, message, details, actions);
    });

    // Initial load
    loadDatabaseStats();

    // Button event listeners - Home Screen
    document.getElementById('refresh-stats').addEventListener('click', loadDatabaseStats);
    document.getElementById('create-sample-card').addEventListener('click', createSampleCard);
    document.getElementById('start-practice-btn').addEventListener('click', () => {
      showScreen('setup');

      // Load tags for the selected source language
      const sourceLanguage = document.getElementById('source-language').value;
      loadTagsForSelection(sourceLanguage);
    });

    // Setup Screen
    document.getElementById('back-to-home-btn').addEventListener('click', () => showScreen('home'));
    document.getElementById('create-session-btn').addEventListener('click', createSession);

    // Source language change handler
    document.getElementById('source-language').addEventListener('change', (event) => {
      loadTagsForSelection(event.target.value);
    });

    // Tag selection accordion - properly accessible with keyboard
    document.getElementById('tag-selection-header').addEventListener('click', () => {
      toggleTagSelectionAccordion();
    });

    // Support keyboard activation for accordion header
    document.getElementById('tag-selection-header').addEventListener('keydown', (event) => {
      if (event.key === 'Enter' || event.key === ' ') {
        event.preventDefault(); // Prevent scrolling on Space
        toggleTagSelectionAccordion();
      }
    });

    // Toggle the tag selection accordion open/closed
    function toggleTagSelectionAccordion() {
      const header = document.getElementById('tag-selection-header');
      const content = document.getElementById('tag-selection-content');
      const toggle = document.getElementById('tag-selection-toggle');
      const isExpanded = content.classList.contains('open');
      const newState = !isExpanded;

      // Toggle expanded state
      content.classList.toggle('open', newState);

      // Update ARIA attributes and visual indicator
      header.setAttribute('aria-expanded', newState);
      toggle.textContent = newState ? '▲' : '▼';

      // Announce state change to screen readers
      document.getElementById('tag-selection-status').textContent =
        newState ? 'Tag selection expanded' : 'Tag selection collapsed';

      // If opening, focus the first tag button or action button
      if (newState) {
        const firstButton = content.querySelector('.tag-toggle') ||
                           content.querySelector('.tag-action-btn');
        if (firstButton) {
          setTimeout(() => firstButton.focus(), 50);
        }
      }
    }

    // Tag selection actions
    document.getElementById('select-all-tags').addEventListener('click', () => {
      selectAllTags(true);
    });

    document.getElementById('select-all-tags').addEventListener('keydown', (event) => {
      if (event.key === 'Enter' || event.key === ' ') {
        event.preventDefault(); // Prevent scrolling on Space
        selectAllTags(true);
      }
    });

    document.getElementById('deselect-all-tags').addEventListener('click', () => {
      selectAllTags(false);
    });

    document.getElementById('deselect-all-tags').addEventListener('keydown', (event) => {
      if (event.key === 'Enter' || event.key === ' ') {
        event.preventDefault(); // Prevent scrolling on Space
        selectAllTags(false);
      }
    });

    // Helper function to select or deselect all tags
    function selectAllTags(selected) {
      const tagButtons = document.querySelectorAll('.tag-toggle');
      const action = selected ? 'Selected' : 'Deselected';

      tagButtons.forEach(button => {
        button.classList.toggle('selected', selected);
        button.setAttribute('aria-pressed', selected.toString());
      });

      // Update summary and announce to screen readers
      updateTagSelectionSummary();
      document.getElementById('tag-selection-status').textContent =
        `${action} all tags`;

      // Focus the first tag after selection
      const firstTag = document.querySelector('.tag-toggle');
      if (firstTag) {
        setTimeout(() => firstTag.focus(), 50);
      }
    }

    // Practice Screen
    document.getElementById('submit-answer-btn').addEventListener('click', submitAnswer);

    // Feedback Screen
    document.getElementById('next-card-btn').addEventListener('click', nextCard);

    // Results Screen
    document.getElementById('back-to-home-from-results-btn').addEventListener('click', () => showScreen('home'));
    document.getElementById('start-new-session-btn').addEventListener('click', () => showScreen('setup'));

    // Test notification button (for development)
    if (process.env.NODE_ENV === 'development') {
      // Create test notification button
      const testNotificationBtn = document.createElement('button');
      testNotificationBtn.textContent = 'Test Notifications';
      testNotificationBtn.style.marginTop = '20px';

      // Add to home screen
      document.querySelector('#home-screen .button-container').appendChild(testNotificationBtn);

      // Add event listener
      testNotificationBtn.addEventListener('click', () => {
        notificationSystem.info('Info Notification', 'This is a sample info notification.');

        setTimeout(() => {
          notificationSystem.success('Success Notification', 'This is a sample success notification.');
        }, 1000);

        setTimeout(() => {
          notificationSystem.warning('Warning Notification', 'This is a sample warning notification.');
        }, 2000);

        setTimeout(() => {
          notificationSystem.error(
            'Error Notification',
            'This is a sample error notification.',
            'Here are some details about the error that would help with debugging.'
          );
        }, 3000);
      });
    }

    // Database Management

    // Export Data
    async function exportData() {
      try {
        const result = await window.flashcards.exportDatabase();

        if (!result.success) {
          if (result.reason === 'canceled') {
            // User canceled, just go back to home
            showScreen('home');
            return;
          }

          showOperationResult('Export Failed', 'Failed to export data: ' + (result.reason || 'Unknown error'), [], 'incorrect');
          return;
        }

        // Show success screen
        const stats = [
          { label: 'Flashcards', value: result.stats.flashcardsCount },
          { label: 'Sessions', value: result.stats.sessionsCount }
        ];

        // Add file path in a separate info item, not as a stat with large font
        document.getElementById('operation-result-path').textContent = result.path;
        document.getElementById('operation-result-path-container').style.display = 'block';

        showOperationResult('Export Successful', 'Your data has been successfully exported!', stats, 'correct');
      } catch (error) {
        console.error('Error exporting data:', error);
        showOperationResult('Export Error', 'An error occurred: ' + error.message, [], 'incorrect');
      }
    }

    // Import Data
    async function proceedWithImport() {
      try {
        const importMode = document.getElementById('import-mode').value;

        const result = await window.flashcards.importDatabase({ mode: importMode });

        if (!result.success) {
          if (result.reason === 'canceled') {
            // User canceled, just go back to home
            showScreen('home');
            return;
          }

          showOperationResult('Import Failed', 'Failed to import data: ' + (result.reason || 'Unknown error'), [], 'incorrect');
          return;
        }

        // Show success screen
        const stats = [
          { label: 'Flashcards Imported', value: result.stats.flashcardsImported },
          { label: 'Sessions Imported', value: result.stats.sessionsImported },
          { label: 'Settings Imported', value: result.stats.settingsImported ? 'Yes' : 'No' }
        ];

        if (result.importInfo) {
          stats.push({ label: 'Export Date', value: new Date(result.importInfo.exportDate).toLocaleString() });
          stats.push({ label: 'Exported From', value: `${result.importInfo.appInfo.name} v${result.importInfo.appInfo.version}` });
        }

        showOperationResult('Import Successful', 'Your data has been successfully imported!', stats, 'correct');

        // Refresh database stats
        await loadDatabaseStats();
      } catch (error) {
        console.error('Error importing data:', error);
        showOperationResult('Import Error', 'An error occurred: ' + error.message, [], 'incorrect');
      }
    }

    // Show operation result screen
    function showOperationResult(title, message, stats, resultClass) {
      document.getElementById('operation-result-title').textContent = title;

      const resultContent = document.getElementById('operation-result-content');
      resultContent.textContent = message;
      resultContent.className = 'feedback';
      if (resultClass) {
        resultContent.classList.add(resultClass);
      }

      // Create stats items
      const statsContainer = document.getElementById('operation-result-stats');
      statsContainer.innerHTML = '';

      stats.forEach(stat => {
        const item = document.createElement('div');
        item.className = 'stats-item';

        const value = document.createElement('div');
        value.className = 'stats-value';
        value.textContent = stat.value;

        const label = document.createElement('div');
        label.className = 'stats-label';
        label.textContent = stat.label;

        item.appendChild(value);
        item.appendChild(label);
        statsContainer.appendChild(item);
      });

      // Hide path container by default (will be shown only for export)
      document.getElementById('operation-result-path-container').style.display = 'none';

      showScreen('operationResult');
    }

    // Export/Import Button Listeners
    document.getElementById('export-data-btn').addEventListener('click', exportData);
    document.getElementById('import-data-btn').addEventListener('click', () => showScreen('import'));
    document.getElementById('back-from-import-btn').addEventListener('click', () => showScreen('home'));
    document.getElementById('proceed-import-btn').addEventListener('click', proceedWithImport);
    document.getElementById('back-to-home-from-result-btn').addEventListener('click', () => showScreen('home'));
  </script>
</body>
</html>